#+TITLE: Yathzee Python, SQL, Webapp
#+PROPERTY: header-args :tangle no
#+PROPERTY: header-args+ :results output drawer

* Background
I want to:
- store the individual scores, per user, in a SQL database.
  + the SQL database has to have both a game ID and a player id. The game ID is a separate table that then holds which players are in a game. Each player has their own table, with game IDs.
- have a QT or webapp interface for plotting of results over time
  + the webapp has to be able to plot results, using a range

* Grab data
:PROPERTIES:
:header-args:python: :shebang "#!/usr/bin/env python"
:header-args:python+: :tangle scripts/prepare_data.py
:header-args:python+: :mkdirp yes
:header-args:python+: :session *prepare_data_py*
:END:

I want to use existing data, so I need to extract this first into separate csv files that I can import into an SQL database. For normalization purposed, I want to create 3 tables: /players/ (player_id, name), /games/ (game_id, date, time), and /scores/ with the following columns:

#+begin_example
player_id
game_id
1
2
3
4
5
6
Full House (25)
3 Dezelfde
4 Dezelfde
Kleine straat (30)
Grote straat (40)
Chance
Yahtzee (50)
#+end_example

I will need to extract the scores information from the excel sheet. I will use pandas to do this, to practice with pandas.

#+begin_src python
# * Libraries
import os
import pandas as pd


# * Environment
ifile = "/datadisk/Syncthing/Temporary/Yahtzee_20240825.xlsx"
odir = "/datadisk/Private/Python/20251222_Yathzee/database"
try:
    os.makedirs(odir)
except FileExistsError as e:
    print("Folder already exists!")


# * Read in database
mypd = pd.read_excel(
    ifile,
    sheet_name = "Score_formulier",
    usecols = "C:IN",
    skiprows = 1,
    nrows = 19,
    header = None
)


# * Drop computed values
# (total, bonus)
mypd = mypd.drop(mypd.index[8:12])


# * Transpose table
mypd = mypd.transpose()


# * Add column names
mypd.columns = ["gamedate", "name", "roll1", "roll2", "roll3", "roll4",
                "roll5", "roll6", "fullh", "same3", "same4", "strsm", "strlg",
                "chanc", "yathz"]


# * Split 'Vincent' and 'Stefanie' data
vkpd = mypd[mypd['name'].isin(['Vincent'])]
sbpd = mypd[mypd['name'].isin(['Stefanie'])]


# * Generate unique identifiers per game
# For matching, the games need to have unique identifiers. The date (gamedate)
# variable is not unique, as the time is not entered. So, I will need to create
# a new ID that adds time, and unique times per game.

# ** Function to create a unique gamedate ID from existing gamedate ID
# def genuniq(ipd):

#     # *** Unique game dates
#     ugames = ipd.loc[:,"gamedate"].unique()

#     # *** Loop over unique values
#     for u in ugames:

#         # Generate a range of unique consequtive numbers (the hours) for each
#         # row for a given date. So, subset the df where the date is u, then
#         # use this in a range function to generate the list of consequtive
#         # numbers.
#         ipd.loc["myhours"] = range(ipd.loc[ipd['gamedate'].isin([u])].shape[0])

#         # Add a column with consequtive numbers in for the rows matching the date
#         ipd.loc[ipd['gamedate'].isin([u]), 'hour'] = myhours

#     # *** Merge the hours with the date
#     # Convert to date/time column
#     ipd.loc[:,"gamedate"] = pd.to_datetime(ipd.loc[:,"gamedate"])

#     # Column
#     ipd.loc[:,"gamedate"] = pd.to_datetime({
#         "year": ipd.gamedate.dt.year,
#         "month": ipd.gamedate.dt.month,
#         "day": ipd.gamedate.dt.day,
#         "hour": ipd.gamedate.myhours,
#         "minute": 0,
#         "second": 0
#     })

#     # *** Drop myhours column
#     ipd = ipd.drop(columns = ["myhours"])

#     # *** Return data frame object
#     return(ipd)

# ** Function to create a unique gamedate ID from existing gamedate ID
def genuniq(ipd):
    # *** Make a copy
    ipd = ipd.copy()

    # *** Create myhours by grouping by date and counting from 0
    # The groupby method runs the 'cumcount' (cumulative count) by blocks of
    # unique gamedate values.
    ipd["myhours"] = ipd.groupby("gamedate").cumcount()

    # *** Merge the hours with the date
    ipd["gamedate"] = pd.to_datetime({
        "year":   ipd["gamedate"].dt.year,
        "month":  ipd["gamedate"].dt.month,
        "day":    ipd["gamedate"].dt.day,
        "hour":   ipd["myhours"],
        "minute": 0,
        "second": 0,
    })

    return ipd.drop(columns=["myhours"])


vkpd = genuniq(vkpd)
sbpd = genuniq(sbpd)
#+end_src

* SQL Database
I need to build multiple databases that can be linked.

** Create databases
:PROPERTIES:
:header-args:sqlite:  :tangle scripts/prepare_database.sql
:header-args:sqlite+: :mkdirp yes
:header-args:sqlite+: :session *prepare_datebase_sql*
:END:

#+begin_src sqlite
CREATE TABLE vincent (
    name TEXT PRIMARY KEY NOT NULL,
    gamedate DATETIME NOT NULL,
    roll1 INTEGER,
    roll2 INTEGER,
    roll3 INTEGER,
    roll4 INTEGER,
    roll5 INTEGER,
    roll6 INTEGER,
    fullh INTEGER,
    same3 INTEGER,
    same4 INTEGER,
    strsm INTEGER,
    strlg INTEGER,
    chanc INTEGER,
    yathz INTEGER
    );


-- Import the CSV into this table:
.mode csv
.import --skip 1 /datadisk/Private/Python/20251222_Yathzee/database/vincent.csv yathzee






-- Convert empty values to NULL
UPDATE nomnom SET review = NULL WHERE TRIM(review) = '';
UPDATE nomnom SET health = NULL WHERE TRIM(health) = '';


-- Information about table
-- .schema movies


-- Display names for the first four movies
SELECT name FROM nomnom LIMIT 4;
#+end_src
